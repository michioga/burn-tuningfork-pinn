# 音叉 設計PINN (Tuning Fork Design PINN)

このプロジェクトは、[Burn](https://burn.dev/)フレームワークを使用して構築された、**物理法則情報付きニューラルネットワーク（PINN）** の実装です。
目標とする周波数（Hz）を入力すると、その周波数を実現するための音叉の最適な寸法を予測する**逆設計問題**を解決します。

## 特徴

  - **逆問題解決**: 通常のシミュレーション（寸法→周波数）とは逆に、目標の周波数から最適な寸法を予測します。
  - **ハイブリッド学習**: 高精度なシミュレーションデータと物理法則（片持ち梁の振動方程式）を組み合わせた損失関数により、データへの忠実度と物理的な妥当性を両立させます。
  - **梁理論の選択**: オイラー・ベルヌーイ梁理論とティモシェンコ梁理論を切り替えることができ、物理モデルの精度を調整可能です。
  - **バックエンド選択可能**: コマンドライン引数で計算バックエンド（WGPU, CUDA, NdArray/CPU）を動的に切り替えられます。
  - **インタラクティブな学習UI**: `burn-train`に組み込まれたCUIダッシュボードにより、学習の進捗（損失、学習率など）をリアルタイムで確認できます。

-----

## PINNの仕組み (ハイブリッド学習モデル)

このモデルは、高精度なシミュレーションデータと物理法則を組み合わせた、ハイブリッドなアプローチ（物理法則情報付きニューラルネットワーク、PINN）を採用しています。学習は、**データ損失**と**物理損失**という2種類の誤差を計算し、それらを混ぜ合わせることで進行します。

### 学習ステップの流れ

1.  **データ供給**: `summary_parameters.csv` からデータが一行読み込まれます。この行から、**目標周波数** ($`f_{target}`$) と、シミュレーションによる**正解寸法** ($`\vec{d}_{target}`$) の両方を取り出します。

2.  **モデルによる寸法予測**: ステップ1で取り出した**目標周波数** ($`f_{target}`$) をニューラルネットワークに入力します。ネットワークは、その周波数を実現するのに最適と思われる**予測寸法** ($`\vec{d}_{pred}`$) を出力します。

3.  **損失の計算 (Mix Point)**: 予測結果を評価するために、2つの異なる観点から損失を計算します。

      - **データ損失 ($`L_{data}`$)**: モデルの予測が、高精度なFEMシミュレーションによって得られた「正解の寸法」にどれだけ近いかを評価します。**予測寸法** ($`\vec{d}*{pred}`$) と**正解寸法** ($`\vec{d}*{target}`$) の平均二乗誤差（MSE）を計算します。
      - **物理損失 ($`L_{physics}`$)**: モデルの予測が、物理法則にどれだけ従っているかを評価します。
        1.  **予測寸法** ($`\vec{d}*{pred}`$) を物理方程式に代入し、理論上の**予測周波数** ($`f*{pred}`$) を算出します。
        2.  **予測周波数** ($`f_{pred}`$) と**目標周波数** ($`f_{target}`$) との誤差を計算します。
        3.  予測された寸法が、物理的にありえない値（例: プロングが細すぎる）になっていないかのペナルティも加算します。

4.  **損失の混合とパラメータ更新**: 最終的な損失 ($`L_{total}`$) は、これら2つの損失を混合比率 `alpha` を用いて組み合わせることで決定されます。

    $`
    L_{total} = \alpha \cdot L_{data} + (1 - \alpha) \cdot L_{physics}
    `$

    この合計損失が最小になるように、ニューラルネットワークの内部パラメータが更新されます。このハイブリッドなアプローチにより、モデルは単にデータを暗記するのではなく、「物理法則を満たし、かつ高精度なデータにも準拠する」という、より汎化性能の高い予測能力を学習します。

-----

## 数理的な詳細 (Mathematical Details)

### 1\. ニューラルネットワーク (Forward Pass)

このモデルは、入力層、2つの隠れ層、出力層からなる多層パーセプトロン（MLP）です。

  - **入力**: 目標周波数 $`f_{target}`$ (スカラー値)
  - **処理**:
    1.  **隠れ層1**: $`\vec{h_1} = \text{ReLU}(\text{LayerNorm}(\mathbf{W}*1 f*{target} + \vec{b}_1))`$
    2.  **隠れ層2**: $`\vec{h_2} = \text{ReLU}(\text{LayerNorm}(\mathbf{W}_2 \vec{h_1} + \vec{b}_2))`$
    3.  **出力層**: $`\vec{d}*{out} = \mathbf{W}*{out} \vec{h_2} + \vec{b}_{out}`$
  - **出力**: 各寸法が正の値となるようにsoftplus関数を適用した、5次元のベクトル $`\vec{d}_{pred}`$ は、

    $`
    \vec{d}*{pred} = \text{softplus}(\vec{d}*{out}) = \log(1 + \exp(\vec{d}_{out}))
    `$

    ここで $`\vec{d}_{pred} = [L_h, D_h, L_p, D_p, G_p]`$ は、それぞれ柄の長さ、柄の直径、プロングの長さ、プロングの直径、プロングの間隔を表します。

### 2\. 物理モデル (Physics Model)

`src/physics.rs` の中核は、プロングを円形断面の片持ち梁と見なしたときの基本周波数を計算する式です。プロジェクトでは、`src/constants.rs` の `BEAM_THEORY_CHOICE` 定数で、以下のいずれかの理論を選択できます。

#### オイラー・ベルヌーイ梁理論 (Euler-Bernoulli)

せん断変形を無視した基本的な梁理論です。

$`f_{pred} = \frac{\lambda^2}{2\pi L_p^2} \sqrt{\frac{E \cdot I}{\rho \cdot A}}`$

  - $`A`$: プロングの断面積 ($`A = \frac{\pi}{4} D_p^2`$)
  - $`I`$: プロングの断面二次モーメント ($`I = \frac{\pi}{64} D_p^4`$)

#### ティモシェンコ梁理論 (Timoshenko)

せん断変形と回転慣性を考慮した、より高精度な梁理論です。オイラー・ベルヌーイ理論の周波数 $`f_e`$ を用いて、以下のように近似されます。

$`f_t = \frac{f_e}{\sqrt{1 + \frac{3 E I}{k' G A L_p^2}}}`$

  - $`G`$: せん断弾性係数, $`k'`$: せん断係数, $`\nu`$: ポアソン比

### 3\. 損失関数 (Loss Function)

合計損失 $`L\_{total}`$ は、データ損失と物理損失の加重和として定義されます。

$`L_{total} = \alpha \cdot L_{data} + (1 - \alpha) \cdot L_{physics}`$

  - **データ損失** $`L_{data}`$: 予測寸法と正解寸法の平均二乗誤差です。
    
    $`L_{data} = \text{MSE}(\vec{d}*{pred}, \vec{d}*{target})`$

    
  - **物理損失** $`L\_{physics}`$: 周波数損失とペナルティ損失の和です。
    $`
    L_{physics} = L_{freq} + \sum_{i} w_i L_{penalty, i}
    `$
  - **周波数損失** $`L\_{freq}`$: 物理モデルの予測周波数と目標周波数の二乗相対誤差です。
    
    $`
    L_{freq} = \left( \frac{f_{pred} - f_{target}}{f_{target}} \right)^2
    `$

  - **ペナルティ損失** $`L\_{penalty, i}`$: 予測された寸法が物理的に妥当な範囲に収まるように与える制約です。

-----

## プロジェクト構造

```
.
├── Cargo.toml
├── data/
│   └── summary_parameters.csv  # 学習用のデータセット
├── artifacts/                  # 学習済みモデルやログが保存されるディレクトリ
├── src/
│   ├── main.rs                 # アプリケーションのエントリポイント、CLI引数の解析
│   ├── constants.rs            # 物理定数やモデルの次元に関する定数
│   ├── dataset.rs              # CSVデータセットの読み込みとバッチ処理
│   ├── model.rs                # ニューラルネットワークモデルの定義
│   ├── physics.rs              # 物理法則に基づいた損失関数の定義
│   ├── train.rs                # モデルの学習処理
│   └── infer.rs                # 学習済みモデルを使った推論処理
└── README.md                   # このファイル
```

-----

## セットアップ

1.  **Rust Toolchain**: [公式サイト](https://www.rust-lang.org/tools/install)の手順に従って、最新のRustをインストールします。(このプロジェクトはRust 2024 Editionを使用しています)
2.  **CUDA (任意)**: CUDAバックエンドを使用する場合は、NVIDIAドライバと[CUDA Toolkit](https://developer.nvidia.com/cuda-toolkit)をインストールしてください。
3.  **依存関係のインストール**:
    ```bash
    cargo build --release
    ```

-----

## 使い方

### 学習

以下のコマンドでモデルの学習を開始します。`--backend`フラグで計算バックエンドを選択できます。

  - **WGPU (デフォルト)**
    ```bash
    cargo run --release -- train --backend wgpu
    ```
  - **CUDA**
    ```bash
    cargo run --release -- train --backend cuda
    ```
  - **CPU (NdArray)**
    ```bash
    cargo run --release -- train --backend nd-array
    ```

### 推論

学習が完了すると`artifacts`ディレクトリにモデルが保存されます。以下のコマンドで、指定した周波数に対する音叉の寸法を予測します。

```bash
# 例: 440Hzの音叉の寸法を予測
cargo run --release -- infer --freq 440.0

# CUDAバックエンドで推論する場合
cargo run --release -- --backend cuda infer --freq 440.0
```