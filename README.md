# 音叉 設計PINN (Tuning Fork Design PINN)

このプロジェクトは、[Burn](https://burn.dev/)フレームワークを使用して構築された、物理法則情報付きニューラルネットワーク（PINN）の実装です。
指定された周波数（Hz）を入力すると、その周波数を実現するための音叉の最適な寸法（プロングの長さ、直径など）を予測します。

## ✨ 特徴

- **逆問題解決**: 通常のシミュレーション（寸法→周波数）とは逆に、目標の周波数から最適な寸法を予測します。
- **物理法則情報付き学習**: モデルの損失関数に物理法則（片持ち梁の振動方程式）を組み込むことで、少ないデータでも物理的に妥当な結果を生成します。
- **梁理論の選択**: オイラー・ベルヌーイ梁理論とティモシェンコ梁理論を切り替えることができ、物理モデルの精度を調整可能です。
- **バックエンド選択可能**: コマンドライン引数で計算バックエンド（WGPU, CUDA, NdArray/CPU）を動的に切り替えられます。
- **インタラクティブな学習UI**: `burn-train`に組み込まれたCUIダッシュボードにより、学習の進捗（損失、学習率など）をリアルタイムで確認できます。

## 📂 プロジェクト構造

```
.
├── Cargo.toml
├── data/
│   └── fem_data_augmented.csv  # 学習用のデータセット
├── artifacts/                  # 学習済みモデルやログが保存されるディレクトリ
├── src/
│   ├── main.rs                 # アプリケーションのエントリポイント、CLI引数の解析
│   ├── constants.rs            # 物理定数やモデルの次元に関する定数
│   ├── dataset.rs              # CSVデータセットの読み込みとバッチ処理
│   ├── model.rs                # ニューラルネットワークモデルの定義
│   ├── physics.rs              # 物理法則に基づいた損失関数の定義
│   ├── train.rs                # モデルの学習処理
│   └── infer.rs                # 学習済みモデルを使った推論処理
└── README.md                   # このファイル
```

## セットアップ

1. **Rust toolchain**: [公式サイト](https://www.rust-lang.org/tools/install)の手順に従って、Rustをインストールします。
2. **CUDA (任意)**: CUDAバックエンドを使用する場合は、NVIDIAドライバと[CUDA Toolkit](https://developer.nvidia.com/cuda-toolkit)をインストールしてください。
3. **依存関係のインストール**:

    ```bash
    cargo build
    ```

## 🚀 使い方

### 学習

以下のコマンドでモデルの学習を開始します。`--backend`フラグで計算バックエンドを選択できます。

- **WGPU (デフォルト)**

  ```bash
  cargo run --release -- --backend wgpu train
  ```

- **CUDA**

  ```bash
  cargo run --release -- --backend cuda train
  ```

- **CPU (NdArray)**

  ```bash
  cargo run --release -- --backend nd-array train
  ```

### 推論

学習が完了すると`artifacts`ディレクトリにモデルが保存されます。以下のコマンドで、指定した周波数に対する音叉の寸法を予測します。

```bash
# 例: 440Hzの音叉の寸法を予測
cargo run --release -- infer --freq 440.0

# CUDAバックエンドで推論する場合
cargo run --release -- --backend cuda infer --freq 440.0

```

## 🧠 ハイブリッドモデル（PINN）の仕組み

このモデルは、高精度なシミュレーションデータと物理法則を組み合わせた、ハイブリッドなアプローチ（物理法則情報付きニューラルネットワーク、PINN）を採用しています。学習プロセスは、以下の2種類の「損失（誤差）」を計算し、それらを混ぜ合わせることで機能します。

1.  **データ損失 (Data Loss)** - *シミュレーションデータへの忠実度*
    -   **目的**: モデルの予測が、高精度なFEMシミュレーションによって得られた「正解の寸法」にどれだけ近いかを評価します。
    -   **計算方法**: モデルが予測した寸法と、データセット内の正解の寸法との**平均二乗誤差（MSE）**を計算します。
    -   **役割**: FEMデータをアンカーポイントとして、モデルの予測精度を高めます。

2.  **物理損失 (Physics Loss)** - *物理法則への準拠度*
    -   **目的**: モデルの予測が、物理法則（この場合は片持ち梁の振動理論）にどれだけ従っているかを評価します。
    -   **計算方法**: 
        1.  モデルが予測した寸法を物理方程式に代入し、理論上の周波数を算出します。
        2.  算出した理論周波数と、目標の周波数との誤差を計算します。
        3.  予測された寸法が、物理的にありえない値（例: プロングが長すぎる）になっていないかどうかのペナルティも加算します。
    -   **役割**: データが存在しない未知の領域でも、モデルが物理的に妥当な予測を行えるようにガイドします。

### 損失の混合と学習

最終的な損失 `Total Loss` は、これら2つの損失を**混合比率 `alpha`** を用いて動的に組み合わせることで決定されます。

$`
\text{Total Loss} = \alpha \cdot (\text{Data Loss}) + (1 - \alpha) \cdot (\text{Physics Loss})
`$

-   `alpha` が `1.0` に近いほど、FEMデータの再現性を重視します。
-   `alpha` が `0.0` に近いほど、物理法則への準拠を重視します。

この `alpha` の値は `src/train.rs` 内で調整可能です。このハイブリッドなアプローチにより、モデルは単にデータを暗記するのではなく、「物理法則を満たし、かつ高精度なデータにも準拠する」という、より汎化性能の高い賢い予測能力を学習します。

### 物理損失で使われる理論式

物理損失の計算には、以下の片持ち梁の振動に関する方程式が用いられます。ニューラルネットワークが予測した寸法（プロングの長さ `L` と直径 `d`）から周波数 `f` を算出します。

プロジェクトでは、`src/constants.rs` の `BEAM_THEORY_CHOICE` 定数で、以下のいずれかの理論を選択できます。

#### 1. オイラー・ベルヌーイ梁理論 (Euler-Bernoulli Beam Theory)

せん断変形と回転慣性を無視した、最も基本的な梁理論です。細くて長い梁に適用されます。

1.  **断面積 (Area)**:
    $`
A = \frac{\pi d^2}{4}
`$

2.  **断面二次モーメント (Moment of Inertia)**:
    $`
I = \frac{\pi d^4}{64}
`$

3.  **周波数 (Frequency)**:
    $`
f = \frac{k}{2\pi L^2} \sqrt{\frac{E \cdot I}{\rho \cdot A}}
`$

#### 2. ティモシェンコ梁理論 (Timoshenko Beam Theory)

せん断変形と回転慣性を考慮した、より高精度な梁理論です。太くて短い梁や高周波振動に適用されます。オイラー・ベルヌーイ理論の周波数 `f_e` を用いて、以下のように近似されます。

$`
f_t = \frac{f_e}{\sqrt{1 + \frac{3 E I}{k' G A L^2}}}
`$

ここで、
-   `f_e`: オイラー・ベルヌーイ梁理論による周波数
-   `G`: せん断弾性係数 ($`G = \frac{E}{2(1 + \nu)}`$)
-   `k'`: せん断係数（円形断面の場合 $`k' = \frac{6(1 + \nu)}{7 + 6\nu}`$）
-   `ν`: ポアソン比 (`POISSON_RATIO`)

共通の定数:
-   `E`: ヤング率 (`YOUNGS_MODULUS`)
-   `ρ`: 材料の密度 (`DENSITY`)
-   `k`: 振動モードの定数 (`K_FACTOR`)

```