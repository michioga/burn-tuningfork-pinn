# 音叉設計のためのデータ駆動型ニューラルネットワーク

このプロジェクトは、[Burn](https://burn.dev/)フレームワークを使用して構築された、**データ駆動型のニューラルネットワーク**です。目標とする周波数（Hz）を入力すると、その周波数を実現するための音叉の最適な5つの寸法を予測する**逆設計問題**を解決します。

当初は物理情報ニューラルネットワーク（PINN）として開発を進めましたが、調査の結果、単純な物理モデルでは音叉の複雑な挙動を正確に表現できず、学習のガイドとして機能しないことが判明しました。この知見に基づき、現在は高忠実度のFEMシミュレーションデータを正解とする、純粋なデータ駆動アプローチを採用しています。

一連のデバッグと改善（特に**入力特徴量エンジニアリング**と**推論コードのバグ修正**）を経て、現在は周波数入力に対して物理的に妥当な寸法を安定して予測できるモデルが完成しています。

## 特徴

- **逆問題解決**: 通常のシミュレーション（寸法→周波数）とは逆に、目標の周波数から最適な寸法を予測します。
- **データ駆動アプローチ**: 1000件のFEMシミュレーションデータを絶対的な「正解」として学習し、複雑な物理現象をデータから直接学習します。
- **特徴量エンジニアリング**: 単一の周波数入力から、`sin`, `cos` を含む4次元の特徴量ベクトルを生成し、モデルが非線形な関係性を学習しやすくしています。
- **高表現力MLPモデル**: 512次元の隠れ層を4層持つ多層パーセプトロン（MLP）を採用。過学習を防ぐ**Dropout**と学習を安定させる**LayerNorm**を各層に配置しています。
- **安定した学習プロセス**: **勾配クリッピング**を導入することで、安定した学習を実現します。

---

## 数理モデル

### 1. 入力特徴量エンジニアリング

モデルは、単一の周波数 `f_input` をそのまま受け取るのではなく、学習効率を高めるために4次元の特徴量ベクトル `x` に変換してから入力します。

1.  まず、入力周波数を正規化し、スケールを調整します。
    $$ f_{norm} = \frac{f_{input}}{1000.0} $$

2.  次に、周期性と非線形性を捉えるための特徴量を生成します。
    $$ x = [ \sin(2\pi f_{norm}), \cos(2\pi f_{norm}), f_{norm}, f_{norm}^2 ] $$

この変換により、単一の数値よりもはるかにリッチな情報をモデルに与えることができ、周波数と寸法の間の複雑な関係性の学習を可能にしています。

### 2. ネットワークアーキテクチャ

モデルは、入力層、4つの隠れ層、出力層から構成されるMLPです。

- **入力層:** 4次元の特徴量ベクトル `x` を受け取ります。
- **隠れ層:** 各隠れ層 `h_i` は、線形変換、Layer Normalization、ReLU活性化関数、Dropoutを順に適用します。
  $$ h_i = \text{Dropout}(\text{ReLU}(\text{LayerNorm}(\text{Linear}_i(h_{i-1})))) $$
  - **隠れ層の次元:** 512
  - **Dropout率:** 20%
- **出力層:** 最終的な5つの寸法 `y_pred` を出力します。負の寸法を避けるため、Softplus活性化関数を適用します。
  $$ y_{pred} = \text{Softplus}(\text{Linear}_{out}(h_4)) $$

### 3. 損失関数

このモデルは純粋なデータ駆動アプローチを採用しているため、損失関数はモデルの予測値 `y_pred` と、FEMデータによる正解値 `y_true` との**平均二乗誤差（MSE）**のみで計算されます。

$$ \mathcal{L}_{total} = \mathcal{L}_{data} = \text{MSE}(y_{pred}, y_{true}) = \frac{1}{N} \sum_{i=1}^{N} (y_{pred, i} - y_{true, i})^2 $$

---

## 開発の経緯と重要な知見

このモデルの開発過程で、いくつかの重要な課題と発見がありました。

1.  **PINNアプローチの限界:** 当初採用した物理情報（ティモシェンコ梁理論）は、実際の音叉の挙動（FEMデータ）と平均200%以上も乖離しており、物理モデルが単純化されすぎていることが判明しました。これにより、PINNアプローチは不適切であると結論付けました。
2.  **データ駆動モデルの学習失敗:** 純粋なデータ駆動モデルに切り替えた後も、モデルは入力周波数を無視して常に同じ平均値を出力する問題が発生しました。
3.  **根本原因の特定と解決:**
    - **入力の正規化:** 学習時と推論時で入力データのスケールが異なっていることが、学習を阻害する根本的なバグであることを特定し、修正しました。
    - **特徴量エンジニアリング:** さらに、単一の周波数入力から複数の特徴量を生成することで、モデルが周波数と寸法の関係性を学習できるようになり、問題が完全に解決しました。

---

## プロジェクト構造

```
.
├── Cargo.toml
├── data/
│   └── summary_parameters.csv  # 学習用のFEMデータセット (1000件)
├── artifacts/                  # 学習済みモデルやログが保存される
├── src/
│   ├── main.rs                 # エントリポイント、CLIの定義
│   ├── constants.rs            # 物理定数、モデルの次元定義
│   ├── dataset.rs              # CSVデータセットの読み込みと特徴量エンジニアリング
│   ├── model.rs                # 4層MLPモデルの定義
│   ├── physics.rs              # 損失関数の定義
│   ├── train.rs                # モデルの学習処理
│   └── infer.rs                # 学習済みモデルを使った推論処理
└── README.md                   # このファイル
```

---

## セットアップ

1.  **Rust Toolchain**: [公式サイト](https://www.rust-lang.org/tools/install)の手順に従って、最新のRustをインストールします。
2.  **依存関係のインストール**:
    ```bash
    cargo build --release
    ```

---

## 使い方

### 学習

以下のコマンドでモデルの学習を開始します。`--backend`フラグで計算バックエンド（`wgpu`, `cuda`, `cpu`）を選択できます。

```bash
cargo run --release -- --backend cuda train
```

### 推論

学習が完了すると`artifacts`ディレクトリにモデルが保存されます。以下のコマンドで、指定した周波数に対する音叉の寸法を予測します。

```bash
# 例: 440Hzの音叉の寸法を予測
cargo run --release -- --backend cuda infer --freq 440.0
```
